<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Qlang — All-in-One Browser Interpreter By Hersh</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root { --bg:#0f1720; --card:#0b1220; --accent:#2563eb; --muted:#94a3b8; --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace; }
    body { margin:0; font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:linear-gradient(180deg,#071126 0%, #071428 100%); color:#e6eef8; }
    .wrap { max-width:1100px; margin:28px auto; padding:20px; }
    .card { background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); border-radius:12px; padding:16px; box-shadow:0 6px 30px rgba(2,6,23,0.6); }
    h1{margin:0 0 8px;font-size:22px}
    textarea{width:100%;height:280px;border-radius:8px;padding:12px;background:#051025;color:#dff2ff;border:1px solid rgba(255,255,255,0.04);font-family:var(--mono);font-size:13px;resize:vertical}
    select,input[type=number]{padding:8px;border-radius:8px;background:#061528;border:1px solid rgba(255,255,255,0.04);color:#dff2ff}
    button{background:var(--accent);border:none;padding:10px 14px;border-radius:8px;color:white;cursor:pointer}
    .small{font-size:13px;color:var(--muted)}
    .muted{color:var(--muted)}
    pre.output{white-space:pre-wrap;background:#041022;padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);font-family:var(--mono);font-size:13px;max-height:360px;overflow:auto}
    .right{width:420px}
    canvas{background:transparent}
    .circuit{font-family:var(--mono);font-size:12px;background:#02111c;padding:10px;border-radius:8px;margin-top:8px;overflow:auto;border:1px solid rgba(255,255,255,0.02)}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .chip{background:#07162a;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,0.02);font-size:13px;display:flex;align-items:center;gap:8px}
    .footer{font-size:12px;color:var(--muted);margin-top:12px}
    .dropzone{border:2px dashed rgba(255,255,255,0.2); border-radius:12px; padding:12px; text-align:center; transition:.2s; background:#08152a; cursor:pointer}
    .dropzone.dragover{border-color:#6ea8ff; background:#0b1e3d}
    .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    a.link{color:#9bd0ff;cursor:pointer;text-decoration:underline}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Qlang — All-in-One Browser Interpreter By Hersh</h1>
      <div class="small">Type Qlang, drop a <code>.qlang</code> file, or load an example. Runs entirely in your browser.</div>
      <div style="height:12px"></div>

      <div style="display:grid; grid-template-columns: 1fr 420px; gap:16px">
        <div>
          <div class="toolbar">
            <div id="dropzone" class="dropzone" title="Click to choose a .qlang file, or drag & drop here">
              <strong>Drop .qlang file here</strong> or click to choose
              <input id="fileInput" type="file" accept=".qlang,.txt" style="display:none">
            </div>
            <span class="small">Examples:
              <a class="link" onclick="loadExample('bell')">Bell</a> ·
              <a class="link" onclick="loadExample('tele')">Teleportation</a> ·
              <a class="link" onclick="loadExample('grover')">Grover</a> ·
              <a class="link" onclick="loadExample('bv')">Bernstein–Vazirani</a>
            </span>
          </div>

          <div style="height:10px"></div>
          <label class="small">Qlang Editor</label>
          <textarea id="editor"># Bell state (entanglement)
qubit q0
qubit q1

hadamard q0
cnot q0,q1

measure all</textarea>

          <div class="controls">
            <div class="chip">Mode:
              <select id="mode">
                <option value="single">single (sample)</option>
                <option value="probability">probability (exact)</option>
              </select>
            </div>
            <div class="chip">Shots: <input id="shots" type="number" min="1" value="1000" style="width:90px"></div>
            <div class="chip">Workers: <input id="workers" type="number" min="1" max="16" value="4" style="width:70px"><span class="small muted">(UI hint)</span></div>

            <div style="margin-left:auto; display:flex; gap:8px">
              <button id="runBtn">Run</button>
              <button id="clearBtn" style="background:#25344f">Clear</button>
              <button id="downloadCsv" style="background:#0b6b63">Download CSV</button>
            </div>
          </div>

          <div style="height:12px"></div>
          <div class="card" style="padding:10px;background:linear-gradient(180deg,#051428,#041022);border-radius:10px">
            <div class="small">Output</div>
            <pre id="output" class="output"></pre>
          </div>
        </div>

        <div class="right">
          <div class="card" style="padding:12px">
            <div style="display:flex;align-items:center;justify-content:space-between">
              <div><strong>Circuit preview</strong><div class="small muted">sequential ASCII layers</div></div>
              <div class="small">Qubit cap: <span class="chip">~12 recommended</span></div>
            </div>
            <div id="circuit" class="circuit">(run to preview)</div>
            <div style="height:12px"></div>

            <div style="display:flex;gap:8px;align-items:center">
              <strong>Histogram</strong>
              <div style="margin-left:auto" class="muted small">Exact in probability mode</div>
            </div>
            <canvas id="histChart" width="380" height="220"></canvas>
            <div style="height:8px"></div>
            <div class="small muted">Note: simulation scales as 2^n. Keep n ≤ 10–12.</div>
          </div>
        </div>
      </div>

      <div class="footer">Supported: <code>qubit</code>, <code>h|hadamard</code>, <code>x,y,z,s,t</code>, <code>cnot</code>, <code>cz</code>, <code>swap</code>, <code>oracle_mark &lt;bits&gt;</code>, <code>grover_diffusion</code>, <code>measure &lt;q|all&gt;</code>, and simple conditionals: <code>if qX == 0|1 then &lt;cmd&gt;</code>.</div>
    </div>
  </div>

<script>
/* ========================= Qlang Browser Simulator (All-in-One) =========================
   Complex numbers, linear algebra, interpreter, simulator, UI glue, drag & drop.
   Educational use; memory/time grows as 2^n.
*/

/* ---------- Complex helpers ---------- */
function c(re, im) { return {r: re, i: im}; }
function cadd(a,b){return {r:a.r+b.r, i:a.i+b.i};}
function csub(a,b){return {r:a.r-b.r, i:a.i-b.i};}
function cmul(a,b){ return { r: a.r*b.r - a.i*b.i, i: a.r*b.i + a.i*b.r }; }
function cscale(a,s){ return { r: a.r*s, i: a.i*s }; }
function cconj(a){ return { r: a.r, i: -a.i }; }
function cmag2(a){ return a.r*a.r + a.i*a.i; }

/* ---------- Matrices & ops ---------- */
function zeros(n){ let A = new Array(n); for(let i=0;i<n;i++) A[i]=c(0,0); return A; }
function matVecMul(mat, vec){
  const N = mat.length; let out = new Array(N);
  for(let i=0;i<N;i++){ let acc=c(0,0); for(let j=0;j<N;j++){ acc=cadd(acc, cmul(mat[i][j], vec[j])); } out[i]=acc; }
  return out;
}
function expandSingleQubitDense(mat, n, targetIndex){
  const N = 1<<n; let U = new Array(N); for(let i=0;i<N;i++){ U[i]=new Array(N); for(let j=0;j<N;j++) U[i][j]=c(0,0); }
  for(let i=0;i<N;i++){
    const bit_i = (i >> (n-1-targetIndex)) & 1;
    for(let b=0;b<2;b++){
      let j = (i & (~(1 << (n-1-targetIndex)))) | (b << (n-1-targetIndex));
      U[j][i] = cadd(U[j][i], mat[b][bit_i]);
    }
  }
  return U;
}
function expandControlledDense(U_target, n, controlIndex, targetIndex){
  const N = 1<<n; let U = new Array(N); for(let i=0;i<N;i++){ U[i]=new Array(N); for(let j=0;j<N;j++) U[i][j]=c(0,0); }
  for(let basis=0; basis<N; basis++){
    const bitc = (basis >> (n-1-controlIndex)) & 1;
    const bitt = (basis >> (n-1-targetIndex)) & 1;
    if(bitc===0){ U[basis][basis] = cadd(U[basis][basis], c(1,0)); }
    else{
      for(let outt=0; outt<2; outt++){
        let j = (basis & (~(1 << (n-1-targetIndex)))) | (outt << (n-1-targetIndex));
        U[j][basis] = cadd(U[j][basis], U_target[outt][bitt]);
      }
    }
  }
  return U;
}

/* ---------- Gate defs ---------- */
const X = [[c(0,0), c(1,0)], [c(1,0), c(0,0)]];
const Y = [[c(0,0), c(0,-1)], [c(0,1), c(0,0)]];
const Z = [[c(1,0), c(0,0)], [c(0,0), c(-1,0)]];
const H = (function(){ const s = 1/Math.sqrt(2); return [[c(s,0), c(s,0)], [c(s,0), c(-s,0)]]; })();
const S = [[c(1,0),c(0,0)],[c(0,0),c(0,1)]];
const T = [[c(1,0),c(0,0)],[c(0,0), c(Math.cos(Math.PI/4), Math.sin(Math.PI/4))]];

/* ---------- Interpreter ---------- */
function parseQlangLines(lines){
  const cmds = [];
  for(const raw of lines){
    let line = raw.replace(/\r/g,'').trim();
    if(line==='') continue;
    if(line.startsWith('#')) { cmds.push({type:'comment'}); continue; }
    if(line.indexOf('#')>=0) line = line.split('#',1)[0].trim();
    if(line==='') { cmds.push({type:'comment'}); continue; }
    const parts = line.split(/\s+/);
    const cmd = parts[0].toLowerCase();
    if(cmd==='qubit'){ if(parts.length<2) throw `Syntax: qubit <name>`; cmds.push({type:'qubit', name: parts[1]}); continue; }
    if(['h','hadamard','x','y','z','s','t'].includes(cmd)){
      if(parts.length<2) throw `${cmd} <qubit>`;
      let mat = (cmd==='h'||cmd==='hadamard')?H : cmd==='x'?X : cmd==='y'?Y : cmd==='z'?Z : cmd==='s'?S : T;
      cmds.push({type:'single_gate', target: parts[1], matrix: mat, name: cmd.toUpperCase()});
      continue;
    }
    if(cmd==='cnot' || cmd==='cz' || cmd==='swap'){
      if(parts.length<2) throw `${cmd} <a>,<b>`;
      const args = parts.slice(1).join('').split(',');
      if(args.length<2) throw `${cmd} expects two qubits separated by comma`;
      if(cmd==='cnot') cmds.push({type:'cnot', control: args[0], target: args[1]});
      if(cmd==='cz')   cmds.push({type:'cz',   control: args[0], target: args[1]});
      if(cmd==='swap') cmds.push({type:'swap', a: args[0], b: args[1]});
      continue;
    }
    if(cmd==='measure'){ if(parts.length<2) throw 'measure <q|all>'; cmds.push({type:'measure', target: parts[1]}); continue; }
    if(cmd==='oracle_mark'){ if(parts.length<2) throw 'oracle_mark <bitstring>'; cmds.push({type:'oracle_mark', bitstring: parts[1]}); continue; }
    if(cmd==='grover_diffusion'){ cmds.push({type:'grover_diffusion'}); continue; }
    if(cmd==='if'){
      const rest = line.slice(2).trim();
      if(rest.indexOf('then')<0) throw "if must contain 'then'";
      const [cond, thenPart] = rest.split(/then/i).map(s=>s.trim());
      let varname, val;
      if(cond.indexOf('==')>=0){ [varname,val] = cond.split('==').map(s=>s.trim()); }
      else if(cond.indexOf('=')>=0){ [varname,val] = cond.split('=').map(s=>s.trim()); }
      else throw "invalid if condition";
      if(!['0','1'].includes(val)) throw "if value must be 0 or 1";
      const inner = parseQlangLines([thenPart]);
      if(inner.length!==1) throw "if then must contain single command";
      cmds.push({type:'if', var: varname, value: parseInt(val), inner: inner[0]});
      continue;
    }
    throw `Unknown command: ${cmd}`;
  }
  return cmds;
}

/* ---------- Circuit ASCII preview ---------- */
function buildCircuitPreview(cmds, qnames){
  const layers = [];
  for(const cmd of cmds){
    if(cmd.type==='comment' || cmd.type==='qubit') continue;
    const layer = {}; qnames.forEach(q=>layer[q]=null);
    if(cmd.type==='single_gate'){ layer[cmd.target] = cmd.name || 'G'; }
    else if(cmd.type==='cnot'){ layer[cmd.control] = '●'; layer[cmd.target] = 'X'; }
    else if(cmd.type==='cz'){ layer[cmd.control] = '●'; layer[cmd.target] = 'Z'; }
    else if(cmd.type==='swap'){ layer[cmd.a]='x'; layer[cmd.b]='x'; }
    else if(cmd.type==='measure'){ if(cmd.target==='all') qnames.forEach(q=>layer[q]='M'); else layer[cmd.target]='M'; }
    else if(cmd.type==='oracle_mark'){ layer[qnames[0]] = `O(${cmd.bitstring})`; }
    else if(cmd.type==='grover_diffusion'){ layer[qnames[0]]='GROV'; }
    else if(cmd.type==='if'){ layer[cmd.var] = `IF(${cmd.value})`; }
    layers.push(layer);
  }
  if(qnames.length===0) return '(no qubits declared)';
  const pad = (s,w)=> s + ' '.repeat(Math.max(0,w-s.length));
  const colW = 10;
  let out = '';
  for(const q of qnames){
    let line = pad(q,12);
    for(let i=0;i<layers.length;i++){
      const cell = layers[i][q];
      if(cell==null) line += '|' + pad('.',colW-1);
      else {
        let s = String(cell);
        if(s.length>colW-1) s = s.slice(0,colW-4)+'...';
        line += '|' + pad(s,colW-1);
      }
    }
    out += line + '\n';
  }
  return out;
}

/* ---------- Simulator ---------- */
class Simulator {
  constructor(){
    this.qubitNames = [];
    this.n = 0;
    this.state = [c(1,0)];
    this.classical = {};
  }
  resetState(){
    if(this.n===0){ this.state=[c(1,0)]; return; }
    let vec = [c(1,0)];
    let zero = [c(1,0), c(0,0)];
    for(let i=0;i<this.n;i++) vec = kronVec(vec, zero);
    this.state = vec;
  }
  addQubit(name){
    if(this.qubitNames.includes(name)) throw `Qubit ${name} already declared`;
    this.qubitNames.push(name);
    this.n = this.qubitNames.length;
    this.resetState();
  }
  applySingleGateByMatrix(mat, targetName){
    const idx = this.qubitNames.indexOf(targetName);
    if(idx<0) throw `Unknown qubit ${targetName}`;
    const U = expandSingleQubitDense(mat, this.n, idx);
    this.state = matVecMul(U, this.state);
  }
  applyCNOT(control, target){
    const cIdx = this.qubitNames.indexOf(control);
    const tIdx = this.qubitNames.indexOf(target);
    if(cIdx<0 || tIdx<0) throw `Unknown qubits in CNOT`;
    const U = expandControlledDense(X, this.n, cIdx, tIdx);
    this.state = matVecMul(U, this.state);
  }
  applyCZ(control, target){
    const cIdx = this.qubitNames.indexOf(control);
    const tIdx = this.qubitNames.indexOf(target);
    const U = expandControlledDense(Z, this.n, cIdx, tIdx);
    this.state = matVecMul(U, this.state);
  }
  applySwap(a,b){ this.applyCNOT(a,b); this.applyCNOT(b,a); this.applyCNOT(a,b); }
  oracleMark(bitstring){
    if(bitstring.length!==this.n) throw 'oracle_mark length mismatch';
    const idx = parseInt(bitstring,2);
    this.state[idx] = cmul(this.state[idx], c(-1,0));
  }
  groverDiffusion(){
    const N = 1<<this.n;
    let avg = c(0,0);
    for(let i=0;i<N;i++) avg = cadd(avg, this.state[i]);
    avg = cscale(avg, 1/N);
    let newState = new Array(N);
    for(let i=0;i<N;i++) newState[i] = csub( cscale(avg, 2), this.state[i] );
    this.state = newState;
  }
  probs(){
    const N = this.state.length; let p = new Array(N); let s=0;
    for(let i=0;i<N;i++){ p[i]=cmag2(this.state[i]); s+=p[i]; }
    if(s>0) for(let i=0;i<N;i++) p[i]/=s;
    return p;
  }
  measureAllSample(){
    const p = this.probs();
    const N = p.length;
    let r = Math.random(); let accum=0; let idx=0;
    for(let i=0;i<N;i++){ accum+=p[i]; if(r<=accum){ idx=i; break; } }
    const bs = idx.toString(2).padStart(this.n,'0');
    let newState = zeros(N); newState[idx]=c(1,0); this.state = newState;
    for(let i=0;i<this.n;i++) this.classical[this.qubitNames[i]] = parseInt(bs[i]);
    return bs;
  }
  measureSingleQubit(name){
    const idx = this.qubitNames.indexOf(name);
    if(idx<0) throw `Unknown qubit ${name}`;
    const N = this.state.length;
    const p = this.probs();
    let p0 = 0;
    for(let i=0;i<N;i++){ const bit = (i >> (this.n-1-idx)) & 1; if(bit===0) p0 += p[i]; }
    const r = Math.random();
    const result = (r<p0)?0:1;
    for(let i=0;i<N;i++){ const bit = (i >> (this.n-1-idx)) & 1; if(bit !== result) this.state[i] = c(0,0); }
    let norm=0; for(let i=0;i<N;i++) norm += cmag2(this.state[i]);
    if(norm>0){ const f = 1/Math.sqrt(norm); for(let i=0;i<N;i++) this.state[i] = cscale(this.state[i], f); }
    this.classical[name]=result;
    return result;
  }
}
function kronVec(a,b){
  const A=a.length, B=b.length; let out=new Array(A*B);
  for(let i=0;i<A;i++) for(let j=0;j<B;j++){
    out[i*B+j]=cmul(a[i], typeof b[j]==='number'? c(b[j],0): b[j]);
  }
  return out;
}

/* ---------- Executor ---------- */
async function executeProgram(text, opts){
  const lines = text.split('\n');
  const cmds = parseQlangLines(lines);
  const qnames = [];
  for(const raw of lines){
    let line = raw.trim();
    if(line===''||line.startsWith('#')) continue;
    if(line.indexOf('#')>=0) line = line.split('#',1)[0].trim();
    if(line==='') continue;
    const parts = line.split(/\s+/);
    if(parts[0].toLowerCase()==='qubit'){ qnames.push(parts[1]); }
  }
  document.getElementById('circuit').textContent = buildCircuitPreview(cmds, qnames);

  if(opts.mode==='probability'){
    const sim = new Simulator();
    sim.qubitNames = qnames.slice(); sim.n=qnames.length; sim.resetState();
    for(const cmd of cmds){
      if(cmd.type==='comment' || cmd.type==='qubit') continue;
      if(cmd.type==='single_gate'){ sim.applySingleGateByMatrix(cmd.matrix, cmd.target); }
      else if(cmd.type==='cnot'){ sim.applyCNOT(cmd.control, cmd.target); }
      else if(cmd.type==='cz'){ sim.applyCZ(cmd.control, cmd.target); }
      else if(cmd.type==='swap'){ sim.applySwap(cmd.a, cmd.b); }
      else if(cmd.type==='oracle_mark'){ sim.oracleMark(cmd.bitstring); }
      else if(cmd.type==='grover_diffusion'){ sim.groverDiffusion(); }
    }
    const probs = sim.probs();
    const out = {};
    for(let i=0;i<probs.length;i++) if(probs[i]>1e-12) out[i.toString(2).padStart(sim.n,'0')] = probs[i];
    return {type:'probability', distribution: out};
  }

  const shots = Math.max(1, Math.floor(opts.shots || 1));
  const results = [];
  for(let s=0;s<shots;s++){
    const sim = new Simulator();
    sim.qubitNames = qnames.slice(); sim.n=qnames.length; sim.resetState();
    sim.classical = {};
    let perShotOutputs = [];
    for(const cmd of cmds){
      if(cmd.type==='comment' || cmd.type==='qubit') continue;
      if(cmd.type==='single_gate'){ sim.applySingleGateByMatrix(cmd.matrix, cmd.target); }
      else if(cmd.type==='cnot'){ sim.applyCNOT(cmd.control, cmd.target); }
      else if(cmd.type==='cz'){ sim.applyCZ(cmd.control, cmd.target); }
      else if(cmd.type==='swap'){ sim.applySwap(cmd.a, cmd.b); }
      else if(cmd.type==='oracle_mark'){ sim.oracleMark(cmd.bitstring); }
      else if(cmd.type==='grover_diffusion'){ sim.groverDiffusion(); }
      else if(cmd.type==='measure'){
        if(cmd.target==='all'){
          const bs = sim.measureAllSample();
          perShotOutputs.push({type:'all', value: bs});
        } else {
          const val = sim.measureSingleQubit(cmd.target);
          perShotOutputs.push({type:'single', name:cmd.target, value: String(val)});
        }
      }
      else if(cmd.type==='if'){
        const varname = cmd.var;
        if(!(varname in sim.classical)) throw `Conditional used on ${varname} before measurement`;
        const val = sim.classical[varname];
        if(val === cmd.value){
          const inner = cmd.inner;
          if(inner.type==='single_gate') sim.applySingleGateByMatrix(inner.matrix, inner.target);
          else if(inner.type==='cnot') sim.applyCNOT(inner.control, inner.target);
          else if(inner.type==='cz') sim.applyCZ(inner.control, inner.target);
          else if(inner.type==='swap') sim.applySwap(inner.a, inner.b);
          else if(inner.type==='oracle_mark') sim.oracleMark(inner.bitstring);
          else if(inner.type==='grover_diffusion') sim.groverDiffusion();
          else throw 'Unsupported conditional inner command';
        }
      }
    }
    if(perShotOutputs.length===0){
      results.push(sim.measureAllSample());
    } else {
      const allEntry = perShotOutputs.filter(x=>x.type==='all');
      if(allEntry.length>0) results.push(allEntry[allEntry.length-1].value);
      else {
        let parts = [];
        for(const q of sim.qubitNames){
          if(q in sim.classical) parts.push(q+'='+sim.classical[q]);
          else parts.push(q+'=U');
        }
        results.push(parts.join(' '));
      }
    }
    if(opts.onProgress && (s%Math.max(1, Math.floor(shots/20))===0)) opts.onProgress(s+1, shots);
    if(s%50===0) await new Promise(r=>setTimeout(r,1));
  }
  const counts = {};
  for(const r of results) counts[r] = (counts[r]||0) + 1;
  return {type:'shots', results: results, counts: counts};
}

/* ---------- UI glue ---------- */
const editor = document.getElementById('editor');
const runBtn = document.getElementById('runBtn');
const outputEl = document.getElementById('output');
const modeSel = document.getElementById('mode');
const shotsInput = document.getElementById('shots');
const workersInput = document.getElementById('workers');
const circuitEl = document.getElementById('circuit');
const chartCanvas = document.getElementById('histChart').getContext('2d');
let chart = null;
let lastShotResultsCsv = null;

function prettyPrintProb(dist){
  const items = Object.entries(dist).sort((a,b)=>b[1]-a[1]);
  let s = '';
  for(const [bs,p] of items) s += `${bs} : ${(p*100).toFixed(6)}%\n`;
  return s;
}
function showHistogramFromCounts(counts){
  const items = Object.entries(counts).sort((a,b)=>b[1]-a[1]);
  const labels = items.map(x=>x[0]);
  const values = items.map(x=>x[1]);
  if(chart) chart.destroy();
  chart = new Chart(chartCanvas, {
    type:'bar',
    data: { labels: labels, datasets: [{ label: 'Counts', data: values }] },
    options: { scales: { y: { beginAtZero:true } }, plugins: { legend:{display:false} } }
  });
}
function showHistogramFromProb(dist){
  const items = Object.entries(dist).sort((a,b)=>b[1]-a[1]);
  const labels = items.map(x=>x[0]);
  const values = items.map(x=>Math.round(x[1]*1000));
  if(chart) chart.destroy();
  chart = new Chart(chartCanvas, {
    type:'bar',
    data: { labels: labels, datasets: [{ label: 'Probability (scaled)', data: values }] },
    options: { scales: { y: { beginAtZero:true } }, plugins: { legend:{display:false} } }
  });
}
function downloadCSV(results){
  const rows = [['shot','result']];
  for(let i=0;i<results.length;i++) rows.push([i+1, results[i]]);
  const csv = rows.map(r => r.map(cell => `"${String(cell).replace(/"/g,'""')}"`).join(',')).join('\n');
  const blob = new Blob([csv], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='qlang_shots.csv'; document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}

runBtn.addEventListener('click', async ()=>{
  outputEl.textContent = 'Running...';
  const code = editor.value;
  const mode = modeSel.value;
  const shots = Math.max(1, parseInt(shotsInput.value || '1'));
  const workers = Math.max(1, parseInt(workersInput.value || '1'));
  try {
    const res = await executeProgram(code, {mode:mode, shots:shots, workers:workers, onProgress: (a,b)=>{ outputEl.textContent = `Running shots: ${a}/${b}...`; }});
    if(res.type==='probability'){
      outputEl.textContent = prettyPrintProb(res.distribution);
      showHistogramFromProb(res.distribution);
      lastShotResultsCsv = null;
    } else if(res.type==='shots'){
      const total = shots;
      let s = `Shots: ${total}\n\nCounts:\n`;
      const ordered = Object.entries(res.counts).sort((a,b)=>b[1]-a[1]);
      for(const [k,c] of ordered) s += `${k} : ${c}\n`;
      s += `\nExample shot outputs (first 30):\n${res.results.slice(0,30).join('\n')}\n`;
      outputEl.textContent = s;
      showHistogramFromCounts(res.counts);
      lastShotResultsCsv = res.results;
    } else {
      outputEl.textContent = 'Unknown result';
      lastShotResultsCsv = null;
    }
  } catch(err){
    outputEl.textContent = 'Error: ' + String(err);
    lastShotResultsCsv = null;
  }
});

document.getElementById('clearBtn').addEventListener('click', ()=>{
  outputEl.textContent=''; if(chart){chart.destroy(); chart=null;}
  circuitEl.textContent='(run to preview)';
});
document.getElementById('downloadCsv').addEventListener('click', ()=>{
  if(!lastShotResultsCsv || lastShotResultsCsv.length===0){ alert('No shot results to save yet. Run with shots ≥ 1.'); return; }
  downloadCSV(lastShotResultsCsv);
});

/* ---------- Drag & Drop + File picker ---------- */
const dropzone = document.getElementById('dropzone');
const fileInput = document.getElementById('fileInput');
dropzone.addEventListener('click', ()=> fileInput.click());
fileInput.addEventListener('change', (e)=>{
  const file = e.target.files[0];
  if(file) readQlangFile(file);
});
dropzone.addEventListener('dragover', (e)=>{ e.preventDefault(); dropzone.classList.add('dragover'); });
dropzone.addEventListener('dragleave', ()=> dropzone.classList.remove('dragover'));
dropzone.addEventListener('drop', (e)=>{
  e.preventDefault(); dropzone.classList.remove('dragover');
  const file = e.dataTransfer.files[0];
  if(file && /\.(qlang|txt)$/i.test(file.name)) readQlangFile(file);
  else alert('Please drop a .qlang or .txt file');
});
function readQlangFile(file){
  const reader = new FileReader();
  reader.onload = evt => { editor.value = evt.target.result; };
  reader.readAsText(file);
}

/* ---------- Examples ---------- */
function loadExample(name){
  const examples = {
    bell: `# Bell state (entanglement)
qubit q0
qubit q1

hadamard q0
cnot q0,q1

measure all`,
    tele: `# Teleportation demo
qubit q_msg
qubit q_alice
qubit q_bob

hadamard q_alice
cnot q_alice,q_bob

# prepare msg
hadamard q_msg

cnot q_msg,q_alice
hadamard q_msg

measure q_msg
measure q_alice

if q_msg == 1 then x q_bob
if q_alice == 1 then z q_bob

measure q_bob`,
    grover: `# Grover demo (2 qubits, target 11)
qubit q0
qubit q1

hadamard q0
hadamard q1

oracle_mark 11
grover_diffusion

measure all`,
    bv: `# Bernstein-Vazirani (secret 101)
qubit a0
qubit a1
qubit a2
qubit anc

x anc
hadamard anc

hadamard a0
hadamard a1
hadamard a2

# Oracle for 101: flip anc controlled on a0 and a2
cnot a0,anc
cnot a2,anc

hadamard a0
hadamard a1
hadamard a2

measure a0
measure a1
measure a2`
  };
  editor.value = examples[name] || '';
}
</script>
</body>
</html>
